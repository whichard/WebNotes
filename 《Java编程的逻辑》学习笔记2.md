# 类

暂且把类看做是函数的容器. 我们**将类看作自定义数据类型**。

所谓自定义数据类型就是除了8种基本类型以外的其他类型，用于表示和处理基本类型以外的其他数据。一个数据类型由其包含的**属性**以及该类型可以进行的**操作**组成，属性又可以分为是类型本身具有的属性，还是一个具体实例具有的属性，同样，操作也可以分为是类型本身可以进行的操作，还是一个具体实例可以进行的操作。
这样，一个数据类型就主要由4部分组成：

- 类型本身具有的属性，通过**类变量**体现。(也叫静态变量，static定义：只有一份，所有类对象共享之，可以通过类名.变量名直接访问)

- 类型本身可以进行的操作，通过**类方法**体现(也叫静态方法)
- 类型实例具有的属性，通过**实例变量**体现
- 类型实例可以进行的操作，通过**实例方法**体现

#### 访问控制AC

- **类方法只能访问类变量**，不能访问实例变量，可以调用其他的类方法，不能调用实例方法。
- 实例方法既能访问实例变量，也能访问类变量，既可以调用实例方法，也可以调用类方法。

不过，对于一个具体类型，每一个部分不一定都有，Arrays类就只有类方法。
类变量和实例变量都叫成员变量，也就是类的成员，类变量也叫静态变量或静态成员变量。类方法和实例方法都叫成员方法，也都是类的成员，类方法也叫静态方法。

### 对象创建

两块内存：一块存放实际内容，一块存放实际内容的位置。声明变量本身只会分配存放位置的内存空间，这块空间还没有指向任何实际内容。因为这种变量和数组变量本身不存储数据，而只是存储实际内容的位置，它们也都称为引用类型的变量。
`p=new Point()；`创建了一个实例或对象，然后赋值给了Point类型的变量p，它至少做了3件事：
1）分配内存，以存储新对象的数据，对象数据包括这个对象的属性，具体包括其实例变量x和y。
2）给实例变量设置默认值，int类型默认值为0。
3) 调用构造方法

与方法内定义的局部变量不同，在创建对象的时候，所有的实例变量都会分配一个默认值，这与创建数组的时候是类似的，数值类型变量的默认值是0，boolean是false，char是\u0000”，引用类型变量都是null。null是一个特殊的值，表示不指向任何对象。

#### 默认值

实例变量都会有一个默认值, 可以通过直接赋值/代码放进初始化代码块中用{}包围(静态变量也可以这样初始化). 新建对象时, **先调用这个初始化, 然后再执行构造方法中的代码**.

#### 构造方法

构造方法用于初始化对象, 对实例变量赋初始值，构造方法可以有多个(参数不同, 重载)。不同于一般方法，构造方法有一些特殊的地方：
1）名称是固定的，与类名相同。这也容易理解，靠这个用户和Java系统就都能容易地知道哪些是构造方法。
2）**没有返回值**，构造方法**隐含**的返回值就是**实例本身**。

​	也不能定义返回值类型：

```java
class Hi {
    public int Hi() { //int需要去掉
        
    }
}
```

与普通方法一样，构造方法也可以重载。第二个构造方法是比较容易理解的，使用this对实例变量赋值。

##### 调用

`Point p=new Point（2，3）；`这个调用就可以将实例变量x和y的值设为2和3。分配内存，给实例变量设置默认值，调用构造方法。**调用构造方法是new操作的一部分**。

##### 默认&自定义构造方法

每个类都**至少要有一个构造方法**，在通过new创建对象的过程中会被调用。但构造方法如果没什么操作要做，可以省略。Java编译器会自动生成一个默认构造方法，也没有具体操作。

但一旦定义了构造方法，Java就不会再自动生成默认的，具体什么意思呢？在这个例子中，如果我们只定义了第二个构造方法（带参数的），则下面语句：`Point p = new point（）；`就会报错，因为找不到不带参数的构造方法。

##### 生命周期

类加载进内存后，一般不会释放，直到程序结束。**一般情况下，类只会加载一次**，**所以**静态变量在内存中只有一份。(如果类加载多次, 那么静态变量在每次类加载时都会创建一次)
当通过new创建一个对象的时候，对象产生，在内存中，会存储这个对象的实例变量值，每做new操作一次，就会产生一个对象，就会有一份独立的实例变量。
每个对象除了保存实例变量的值外，可以理解为还保存着对应类型即**类的地址**，这样，通过对象能知道它的类，访问到类的变量和方法代码。
实例方法可以理解为一个静态方法，只是多了一个参数this。通过对象调用方法，可以理解为就是调用这个静态方法，并将对象作为参数传给this。
对象的释放是被Java用垃圾回收机制管理的，大部分情况下，我们不用太操心，当对象不再被使用的时候会被自动释放。

### import

#### 包

类似文件夹, 访问控制解决命名冲突, 在java中组织类和接口的方式为包. 完全限定名: 带有完整包名的类名

包的引入.*不能递归, 只引入当前层, 子包无关

**可见性范围**从小到大是：private<默认（包）<protected<public。

##### jar包

在Java中，编译后的一个或多个包的Java class文件可以打包为一个文件，Java中打包命令为jar，打包后的文件扩展名为jar，一般称之为jar包。

hello.jar就是jar包，jar包其实就是一个压缩文件，可以使用解压缩工具打开。
Java类库、第三方类库都是以jar包形式提供的。如何使用jar包呢？将其加入类路径（classpath）中即可。类路径是什么呢？我们下面来看。

#### classpath与程序的编译链接

从Java源代码到运行的程序，有编译和链接两个步骤。

- 编译是将源代码文件变成扩展名是.class的一种字节码，这个工作一般是由javac命令完成的。
- 链接是在运行时动态执行的，class文件不能直接运行，运行的是Java虚拟机，虚拟机听起来比较抽象，执行的就是Java命令，这个命令解析.class文件，转换为机器能识别的二进制代码，然后运行。所谓链接就是根据引用到的类加载相应的字节码并执行。

Java编译和运行时，都需要以参数指定一个classpath，即类路径。类路径可以有多个，对于直接的class文件，路径是class文件的根目录；对于jar包，路径是jar包的完整名称（包括路径和jar包名）。
在Java源代码**编译时**，Java编译器会**确定引用的每个类**的**完全限定名**，**确定的方式是根据import语句和classpath**。如果导入的是完全限定类名，则可以直接比较并确定。如果是模糊导入（import带.*），则根据classpath找对应包，再在包下寻找是否有对应的类。如果多个模糊导入的包下都有同样的类名，则Java会提示编译错误，此时应该明确指定导入哪个类。
Java运行时，会根据类的完全限定名寻找并加载类，寻找的方式就是在类路径中寻找，如果是class文件的根目录，则直接查看是否有对应的子目录及文件，如果是jar文件，则首先在内存中解压文件，然后再查看是否有对应的类。

### !!类加载--反复看 对应书中的4.3 继承实现的原理 

```java
public class Base{
    public static int s；//静态变量, 对象创建过程不能赋值--和对象无关; 变量操作:通过创建Base类对象
    private int a；//实例变量
    static{
        System.out.print1n（"基类静态代码块，s:"+s）；
        s=1；
    }
    {
        System.out.println（"基类实例代码块，a:"+a）；
        a=1；
    }
    public Base（）{
        System.out.println（"基类构造方法，a:"+a）；
        a=2；
    }
    protected void step（）{
        System.out.printin（"base s:"+s +"，a:"+a）；
    }
    public void action（）{
        System.out.println（"start"）；
        step（）；
        System.out.print1n（"end"）；
    }
}

public class Child extends Base{
	public static int s；
	private int a；
	static{
		System.out.print1n（"子类静态代码块，s:"+s）；
		s=10；
	}
	{
		System.out.print1n（"子类实例代码块，a:"+a）；
		a=10；
	}
	public Child（）{
		System.out.print1n（"子类构造方法，a:"+a）；a=20；
	}
	protected void step（）{
		System.out.printin（"childs:"+s+"，a:"+a）；
	}
}

public static void main(String[] args){ 
    System.out.println("----new Child()"); 
    Child c=new Child(); 
    System.out.println("\n----c. action()"); 
    c.action(); 
    Base b=c; 
    System.out.println("\n----b. action()"); 
    b.action(); 
    System.out.println("\n----b.s:"+b.s); 
    System.out.println("\n----c.s:"+c.s);
}
/*执行结果
----new Child（）
基类静态代码块，s：0
子类静态代码块，s：0
基类实例代码块，a：0
基类构造方法，a：1
子类实例代码块，a：0
子类构造方法，a：10
-—-c.action（）
start 
childs：10，a：20
end
-—-b.action（）
start 
childs：10，a：20
end
---b.s：1
----c.s：10
*/
```

#### 类加载过程包括：

- 分配内存保存类的信息；
- 给类变量赋默认值；
- 加载父类；(注意这一步是**递归**的, 直到加载到Object类)
- 设置父子关系；
- 执行类初始化代码。先执行父类的，再执行子类的。

#### 对象创建

在类加载之后，new Child（）就是创建Child对象，创建对象过程包括：
1）分配内存；
2）对所有**实例变量**赋默认值；
3）执行实例初始化代码。
分配的内存包括本类和所有父类的实例变量，但不包括任何静态变量。**实例初始化代码的执行从父类开始，再执行子类的**。但在任何类执行初始化代码之前，所有实例变量都已设置完默认值。
每个对象除了保存类的实例变量之外，还保存着实际类信息的引用。

#### 方法调用的过程--动态绑定

我们先来看c.action()；，这句代码的执行过程：
1）查看c的对象类型，找到Child类型，在Child类型中找action方法，发现没有，到父类中寻找；
2）在父类Base中找到了方法action，开始执行action方法；
3）action先输出了start，然后发现需要调用step()方法，就从Child类型开始寻找step()方法；
4）在Child类型中找到了step()方法，执行Child中的step()方法，执行完后返回action方法；
5）继续执行action方法，输出end。
寻找要执行的实例方法的时候，是从**对象的实际类型**`Base b = new Child(); b的实际类型为Child`信息开始查找的，找不到的时候，再查找父类类型信息。(逻辑: 子类可以重新实现方法对父类的同名方法进行覆盖)
我们来看b.action()，**这句代码的输出和c.action()是一样**的，这称为**动态绑定**，而动态绑定实现的机制就是**根据对象的实际类型查找要执行的方法**，**子类型中找不到的时候再查找父类**。这里，因为b和c指向相同的对象，所以执行结果是一样的。
如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要进行很多次查找。大多数系统使用一种称为虚方法表的方法来优化调用的效率。
所谓虚方法表，就是在类加载的时候为每个类创建一个表，记录该类的对象所有动态绑定的方法（包括父类的方法）及其地址，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。对于本例来说，Child和Base的虚方法表如图4-5所示。

#### 变量访问的过程--静态绑定

**对变量的访问是静态绑定的**，无论是类变量还是实例变量。代码中演示的是类变量：b.s和c.s，通过对象访问类变量，系统会转换为直接访问类变量Base.s和Child.s。

#### 谨慎使用继承

继承破坏封装: 继承可能破坏封装是因为子类和父类之间可能存在着实现细节的依赖。**耦合.** 

如果子类不知道基类方法的实现细节，它就不能正确地进行扩展。 子类父类不能随意修改.

##### 避免继承

避免继承，有三种方法：

- 使用final关键字； --final方法不能被重写，final类不能被继承, 让父类可以随性修改, 而其对子类申明的功能不变
- 优先使用组合而非继承；使用组合可以抵挡父类变化对子类的影响，从而保护子类，应该优先使用组合。
- 使用接口。

##### 合理的使用继承

见book.



## 类的拓展

### 接口interface

只关心能力, 不关心类型实现(你是什么类无所谓, 只要能完成接口定义的功能, 反应了对象以及对象操作的本质)

解耦合: 双方对象并不存在相互依赖关系, 只是通过接口间接通信交互

实际应用: 使用接口定义功能, 同时使用一个与之关联的抽象类实现默认功能.

面向接口编程是重要的思想方法.

#### 定义

Java8之前，接口内不能实现方法。接口方法不需要加修饰符，加与不加相当于都是public abstract。

需要至少两个参与者: 一个实现接口, 一个使用接口.

#### 实现

类可以实现接口，表示类的对象具有接口所表示的能力

通过关键字implements来使用接口, 通过注解@Override一个同名方法来实现接口定义的功能(覆盖抽象类的默认方法实现)

```java
public class Point implements MyComparable{
    ...
    @Override
    public int compareTo(Object obj){
        ...
    }
}
```

#### 使用

**对象只能通过类来创建**, 接口不能new.

如果一个类型实现了多个接口, 那么可以把这个类型的对象赋给其中任一**接口类型的变量**(如下所示, Point实现了MyComparable接口.)

```java
MyComparable p = new Point();
//MyComparable为接口类型, Point为实现.
//p只能调用MyCompareble的方法, 执行时执行Point中的实现代码.
```

面向接口编程: 上述例子中, p只能调用MyCompareble的方法, 执行时执行Point中的实现代码. 我们可以**只关心接口需要的功能**, 而**不需要知道具体的类型!**

##### 变量

在接口中定义变量, 修饰符使用 public static final 不写编译器也默认加. 变量通过接口名.变量名的方式使用.

##### 继承

接口可以继承多个父接口.

##### 判断一个对象是否实现了某个接口

和类一样, 使用instanceof关键字来判断.

`if(p instanceof MyComparable) `

#### 用接口+组合替代继承

接口: 统一处理, 组合: 复用代码

继承至少有两个好处：一个是复用代码；另一个是利用多态和动态绑定统一处理多种不同子类的对象。使用组合替代继承，可以**复用代码**，但不能统一处理。使用接口替代继承，针对接口编程，可以实现**统一处理**不同类型的对象，但接口没有代码实现，无法复用代码。将组合和接口结合起来替代继承，就既可以统一处理，又可以复用代码了。

#### 默认方法和静态方法

在java 8之前，接口中的方法都是抽象方法，都没有实现体，Java8允许在接口中定义两类新方法：静态方法和默认方法，它们**有实现体**，比如：

```java
public interface IDemo{
    void he11o（）；
    public static void test（）{ //静态方法 通过IDemo.test()调用
    	System.out.print1n（"hel1o"）；
    }
    default void hi（）{ //默认方法, 可覆盖
 	   System.out.print1n（"hi"）；
    }
}
```

test（）就是一个静态方法，可以通过IDemo.test（）调用。在接口不能定义静态方法之前，相关的静态方法往往定义在单独的类中，比如，JavaAPl中，Collection接口有一个对应的单独的类Collections，在Java8中，就可以直接写在接口中了，比如Comparator接口就定义了多个静态方法。
hi（）是一个默认方法，用关键字default表示。默认方法与抽象方法都是接口的方法，不同在于，默认方法有默认的实现，实现类可以改变它的实现，也可以不改变。引入默认方法主要是函数式数据处理的需求，是为了**便于给接口增加功能**。关于函数式数据处理，会在第26章介绍。

### 抽象类

本节介绍了抽象类，相对于具体类，它用于表达抽象概念，虽然从语法上抽象类不是必需的，但它能使程序更为清晰，可以**减少误用**。**抽象类和接口经常相互配合，接口定义能力**，而抽象类**提供默认实现**，方便子类实现接口。

#### 抽象方法&使用规定

抽象方法只有声明没有实现, 只有子类才知道如何实现的方法, 一般定义为抽象方法`Shape()为抽象方法, 具体的Square(), Triangle()等为子类的具体方法.`

定义了抽象方法的类必须被声明为抽象类，不过，抽象类可以没有抽象方法。抽象类和具体类一样，可以定义具体方法、实例变量等，它和具体类的核心区别是，抽象类**不能创建对象**, 要创建对象必须使用它的具体子类.

抽象类不能创建对象，要创建对象，必须使用它的具体子类。一个类在继承抽象类后**，必须实现抽象类中定义的所有抽象方法**，除非它自己也声明为抽象类。

#### 与接口的配合

一个接口往往有一个对应的抽象类.

##### 与接口的相似与不同

抽象类和接口有类似之处：都不能用于创建对象，接口中的方法其实都是抽象方法。如果抽象类中只定义了抽象方法，那抽象类和接口就更像了。但抽象类和接口根本上是不同的，**接口中不能定义实例变量，而抽象类可以**，一个类可以实现多个接口，但**只能继承一个类**。

##### 配合使用

抽象类和接口是配合而非替代关系，它们经常一起使用，接口声明能力，抽象类提供默认实现，实现全部或部分方法，一个接口经常有一个对应的抽象类。

对于需要实现接口的具体类而言，有两个选择：一个是实现接口，自己实现全部方法；另一个则是继承抽象类，然后**根据需要重写方法**。
继承的好处是复用代码，只重写需要的部分即可，需要编写的代码比较少，容易实现。不过，如果这个具体类已经有父类了，那就只能选择实现接口了。

### !内部类 反复看

成员静态, 方法匿名.

内部类是一个编译器概念, 虚拟机不知道这个概念: 每个内部类都被编译成一个独立的类(都可以等价替换为一个独立的类). 既然如此为何使用? 方便的访问外部类的私有变量, 更好的封装隐藏, 代码简洁.

方法内部类把变量修改为单值数组的操作, 可以理解为变相的指针操作

#### 静态内部类

位置放在类的内部, 几乎相当于一个独立的类, 只是能访问外部类的静态变量(编译器实现: 自动为Outer生成一个非私有访问方法access$0，它返回这个私有静态变量shared。).

 public的静态内部类可以通过`Outer.Inner in= new Outer.Inner`直接创建而不依赖外部类. 

如果一个类与外部类关系密切，且不依赖于外部类实例，则可以考虑定义为静态内部类。

> 比如，一个类内部，如果既要计算最大值，又要计算最小值，可以在一次遍历中将最大值和最小值都计算出来，但怎么返回呢？可以定义一个类Pair，包括最大值和最小值，但Pair这个名字太普遍，而且它主要是类内部使用的，就可以定义为一个静态内部类。

#### 成员内部类

在静态内部类的基础上, 增加可以访问外部类的实例方法/变量(如果内外重名, 通过`外部类.this.xxx`来访问)

不独立: 总是和外部类的一个对象相连. 必须通过`创建外部类对象; 外部类对象.new 内部类`来创建, 不能像静态内部类那样, 直接`Outer.Inner in= new Outer.Inner`创建.

```java
Outer out=new Outer();
Outer.Inner inner=out.new Inner();
```

不能创建静态变量, 方法 (final变量除外, 其等同于常量) : 成员匿名方法内部类都不可以. 这是java的规定. 从实现上来说是可以定义的, 为什么规定不允许定义: 总是和外部类关联使用的, 直接定义在外部类中即可, 在内部类中定义的意义不大, 确实有需要的静态变量方法也可以移到外部类中去. 

##### 使用

成员内部类有哪些应用场景呢？如果内部类与外部类关系密切，需要访问外部类的实例变量或方法，则可以考虑定义为成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回这个接口，外部类方法可能使用内部类实现这个接口，这个内部类可以被设为private，对外完全隐藏。

## 常用基础类

### 包装类

自动拆箱装箱是**编译器功能**: 自动替换为调用相应的valueOf/xxxValue方法 

重写Object类的equals方法, hashCode方法(各类hashcode方法见book p140), 实现Comparable接口(只有一个方法compare返回0,+1,-1. 对于Boolean, true>false)

浮点数0.01f和0.1f*0.1f是不相等的

parseInt(String) 返回基本类型int; valueOf(String)返回包装类Integer对象.

6种数值类型有共同的父类Number(抽象类), 通过Number的方法, 包装类的实例可以返回任一类型的基本数值类型.

integer的**reverse方法**:7.1.3 作为例子, 使用移位和多位同时操作来高效运算.

#### 线程安全:不可变性

包装类的实例对象一旦创建就无法改变

实现:

·所有包装类都声明为了final，不能被继承。
·内部基本类型值是私有的，且声明为了inal。
·没有定义setter方法。

### String

java8之前用char数组存string, java9用byte数组表示string(如果全是ASCII码, 可以只用1个字节, 省内存)

```java
String name1=“老马说编程"；
String name2=“老马说编程"；
System.out.println（name1==name2）；//true

String name1=new String（"老马说编程"）；
String name2=new String（"老马说编程"）；//new方法创建了两个不同的对象
System.out.print1n（name1==name2）； //false ==直接比内存地址
System.out.print1n（name1.equals(name2）);//true String类的equals方法重写了Object的equals方法
```

**!看:**java中hashcode的实现方法

string的compareTo方法?

#### StringBuilder

如果字符串修改操作比较频繁，应该采用StringBuilder和StringBuffer类，这两个类的方法基本是完全一样的，它们的实现代码也几乎一样，唯一的不同就在于StringBuffer类是线程安全的，而StringBuilder类不是。

线程安全是有成本的，影响性能，而字符串对象及操作大部分情况下不存在线程安全问题，适合使用String-Builder类。

String的+和+=是一个编译器支持, 生成StringBuilder, +和+=转化为append.

在复杂情况(如循环)下String的运算符可能出错(java编译器没有那么智能, 可能生成过多Builder), 此时应该直接使用StringBuilder

### Arrays

Arrays.sort()方法, 所有基本类型的数组都可用,boolean除外

实现Comparable接口的对象类型数组都可以排序.

char, String数组的排序以ASCII码(大写一定排在小写之前)

#### 自定义sort: 用匿名类实现Comparable接口

```java
String[] arr={"hello","world","Break","abc"}; 
Arrays. sort(arr, new Comparator<String>(){
	@verride 
	public int compare(String ol, String o2){
		return o2.compareToIgnoreCase(o1);//忽略大小写的排序
	}
}); 
System.out.printin(Arrays.toString(arr));
```

sort方法实现, 基础类型用的特殊快排, 对象类型用的优化过的归并排序, 数组规模小的时候直接使用插入排序.

#### Arrays.binarySearch()方法

针对已经排序过的对象数组可用

```java
int[] arr={3,5,7,13,21}; 
System.out.println(Arrays.binarySearch(arr,13));
```

找到返回序号, 没找到返回负数.

## 容器

容器类: 容纳并且管理多项数据的类.

java.util.collection是接口, java.util.collections是其包装类, 有很多静态方法,  不可实例化. 

### TreeMap

!失败, 根据书上的代码, MyEclipse在重写的方法上报错. 重写构造方法实现逆序

```java
Map<String, String> map= new TreeMap<>(new Comparator<String>(){
    @Override
    public int compare(String s1, String s2){
    	return s2.compareTo(s1);
    }
});
```

### LinkedHashMap

利用LinkedHashMap实现LRU缓存.

```java
import java.util.LinkedHashMap;
public class LRUCache {
    private LinkedHashMap<Integer, Integer> map;
    private final int CAPACITY;
    public LRUCache(int capacity) {
        CAPACITY = capacity;
        map = new LinkedHashMap<Integer, Integer>(capacity, 0.75f, true){
            protected boolean removeEldestEntry(Map.Entry eldest) {
                return size() > CAPACITY;
            }
        };
    }
    public int get(int key) {
        return map.getOrDefault(key, -1);
    }
    public void put(int key, int value) {
        map.put(key, value);
    }
}
```

### Synchronized

Synchronized保护的是对象而不是代码. 在保护变量时, 需要在所有访问该变量的方法上加上Synchronized.

进程定义了一个执行环境, 有私有的地址空间, 一个句柄表, 以及一个安全环境; 线程是一个控制流, 有自己的调用栈, 记录执行历史.
